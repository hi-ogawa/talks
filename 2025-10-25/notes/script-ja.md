# トークスクリプト - Vitest アーキテクチャ詳解

**総時間: 33分（Q&A含む）**
**総スライド数: 45枚**

## スライド構成
- イントロダクション: スライド 1-6（タイトル、自己紹介、What is Vitest x3、Vitest 4）
- 概要: スライド 7-9（概要、パッケージ、例）
- テストライフサイクル: スライド 10-32（マーカースライド4枚含む）
  - オーケストレーション: スライド 10-17（マーカー + 7枚）
  - コレクション: スライド 18-21（マーカー + 3枚）
  - 実行: スライド 22-26（マーカー + 4枚）
  - レポーティング: スライド 27-32（マーカー + 5枚）
- Vite統合: スライド 33-44（Where is Vite + カバレッジ含む11枚）
- まとめ: スライド 45（重要ポイント）

---

## イントロダクション（4分）- 0:00-4:00

### スライド 1: タイトル
*0:00-0:30*

「皆さん、こんにちは！今日はVitestのアーキテクチャについて深く掘り下げていきます。内部でどのように動作しているのか、そして何が強力なモダンテストフレームワークにしているのかを理解していきましょう。」

**[間を置いて、次のスライドへクリック]**

---

### スライド 2: 自己紹介
*0:30-1:30*

「簡単に自己紹介します。私はHiroshi Ogawaで、ViteとVitestのコアチームの一員であり、VoidZeroでオープンソース開発者として働いています。SSRメタフレームワークに情熱を持っており、Vite RSCサポートの取り組みを含め、Viteエコシステムに貢献しています。」

**[右側のアバターを指す]**

---

### スライド 3-5: Vitestとは？
*1:30-3:30*

**[スライド 3 - 基本的な例]**

「Vitestが初めての方のために、典型的なテストがどのようなものかをお見せします。describe、test、expectのような馴染みのあるAPIを持つテストフレームワークです。右側にvitestコマンドを実行したときの出力が表示されています。」

**[コードハイライトをクリックしていく]**

**[スライド 4 - 機能]**

「主な機能には次のようなものがあります：Jest互換のAPIと機能セット、ESMとTypeScriptのサポートが標準搭載、React、Vue、Svelte用のViteプラグインによる拡張性、そして重要なのは、Node.js、ブラウザモード、さらにはCloudflare Workersをサポートするランタイム非依存設計です。また、エコシステム全体で強力なカスタマイズを可能にする高度なプログラマティックAPIも提供しています。」

**[スライド 5 - ブラウザモード]**

「こちらがブラウザモードです。同じテストコードがPlaywrightを使用して実際のブラウザ環境で実行され、jsdomシミュレーションではなく本物のブラウザランタイムを提供します。」

---

### スライド 6: Vitest 4 リリース
*3:30-4:00*

「タイミングが良いことに、Vitest 4が10月23日にリリースされたばかりです！ビジュアルリグレッションテストとトレーシングを備えた安定版ブラウザモード、そしてプールシステムの完全な書き直しが含まれています。詳細はアナウンスブログとVladimirのViteConfトークをご覧ください。」

---

## 概要とセットアップ（3分）- 4:00-7:00

### スライド 7: 概要
*4:00-5:00*

「このトークでは、**テストライフサイクル**に沿ってVitestのアーキテクチャを探ります：オーケストレーション、コレクション、実行、そしてレポーティングです。」

**[間を置く]**

「その過程で、どの部分が一般的なテストフレームワークの実装で、ViteがModuleRunnerとブラウザモードでテストランタイムをどのように強化しているか、そして各パッケージがどのように責任を分担しているか（vitest、@vitest/runner、@vitest/browser、@vitest/expect、その他）を探ります。」

---

### スライド 8: Vitestモノレポのパッケージ依存関係
*5:00-6:00*

「こちらがVitestのモノレポパッケージの依存関係グラフです。メインのvitestパッケージはCLIのエントリーポイント、テストオーケストレーション、レポーターを処理します。@vitest/runnerはdescribe/suiteとテスト実行を管理します。@vitest/expect、snapshot、spyは独立したライブラリで、単独でも使用できます。」

**[図を指す]**

---

### スライド 9: テストライフサイクル - 例
*6:00-7:00*

「具体的な例から始めましょう。2つのテストファイルがあります：ネストされたdescribeとテストを持つadd.test.tsと、単一のテストを持つmul.test.tsです。vitestを実行したときに何が起こるか見てみましょう。」

**[右側の出力を表示]**

「このプロセスの各ステップを分解していきます。」

---

### スライド 10: テストライフサイクル - オーケストレーションマーカー
*7:00-7:15*

「では、最初のフェーズに入りましょう：オーケストレーションです。」

**[ライフサイクルの進行を示すシンプルなマーカースライド]**

---

## テストライフサイクル - オーケストレーション（6分）- 7:15-13:15

### スライド 11: テストオーケストレーション概要
*7:15-8:15*

「最初のフェーズはオーケストレーションです。実行するテストファイルを見つけます。」

**[設定とCLIの例をクリックしていく]**

「Vitestはinclude/excludeパターンとプロジェクトを含む設定を使用します。CLI引数でこれらを上書きできます。globパターンを渡したり、プロジェクトをフィルタリングしたり、CI並列化のために複数のマシンにテストをシャーディングすることもできます。」

**[pool.runTestsを表示する最終出力を表示]**

---

### スライド 12-14: プールアーキテクチャ
*8:15-11:15*

**[スライド 12 - Forks]**

「テストファイルが特定されたら、その実行をオーケストレートする必要があります。デフォルトでは、Vitestは`pool: 'forks'`を使用します。Nodeのchild_process.forkを使用して独立した子プロセスを生成します。各プロセスは複数のテストファイルを処理しますが、強力な分離を提供します。これによりCPUベースの並列化が可能になります。」

**[メインプロセスとワーカープロセスを示す図を指す]**

**[スライド 13 - Threads]**

「代替手段は`pool: 'threads'`でワーカースレッドを使用します。子プロセスよりも軽量ですが、ネイティブモジュールとprocess.chdir周りにいくつかの制限があります。互換性に関する注意事項については、Common Errorsドキュメントをご確認ください。」

**[スライド 14 - ブラウザモード]**

「ブラウザモードは異なるアプローチを取ります。PlaywrightまたはWebdriverIOを使用して実際のブラウザコンテキストを起動し、WebSocket通信を介してそこでテストを実行します。」

---

### スライド 15: 分離なしモード
*11:15-12:15*

「`isolate: false`で分離をオプトアウトすることもできます。これにより、複数のテストファイルに対して同じプロセス/ワーカーを再利用し、起動時間を節約してモジュールグラフを再利用できます。ただし、テスト実行順序が結果に影響を与える可能性があるため、速度と決定性の間にトレードオフがあります。」

---

### スライド 16-17: 分離について
*12:15-13:15*

**[スライド 16 - 説明]**

「トレードオフを明確にしましょう。Forksは最も安定しており、本番環境に最も近いため、デフォルトです。isolate: falseモードは、プロセスとモジュールを再利用するため高速になる可能性がありますが、テストファイルが互いに影響を及ぼす可能性があります。ただし、テストはメインプロセスから分離されて実行されます。ガイダンスについては、'Improving Performance'ドキュメントをご覧ください。」

**[スライド 17 - 例]**

「こちらが違いを示す具体的な例です。分離ありでは、shared.tsが2回評価されます。テストファイルごとに1回です。分離なしでは、1回評価されて再利用されますが、テストが並列ではなく順次実行されることに注意してください。」

---

### スライド 18: テストライフサイクル - コレクションマーカー
*13:15-13:30*

「では、コレクションフェーズに移りましょう。」

**[ライフサイクルの進行を示すシンプルなマーカースライド]**

---

## テストライフサイクル - コレクション（4分）- 13:30-17:30

### スライド 19: コレクションフェーズ
*13:30-14:30*

「では、コレクションに移ります。メインプロセスはテストファイルについてのみ知っています。テストケースを発見するには、テストファイルを実行します。」

**[vitest list --jsonの出力を表示]**

「`vitest list`を実行すると、発見されたテストケースがその名前とファイルパスと共に表示されます。」

---

### スライド 20: タスクツリーの作成
*14:30-16:30*

「テストファイルを実行すると、タスクツリーを構築します。@vitest/runnerは型を提供します：TaskはFile、Suite、またはTestになります。」

**[同期されたアニメーションをクリックしていく]**

「describe()が呼び出されると、Suiteを作成します。各test()呼び出しは、実行する関数を持つTestを作成します。最初はすべての結果がundefinedです。」

**[最後のポイントにクリック]**

「このコレクションフェーズは、すべてのトップレベルのimport文が実行され、モジュールグラフ全体が評価されるため、かなりの時間がかかることが多いです。期間に'collect 46ms'と表示されています。」

---

### スライド 21: タスクのフィルタリング
*16:30-17:30*

「コレクション後、フィルタリングはテストランナー側でdescribe.skip/only、test.skip/only、または-tフラグで行われます。重要な注意点：フィルタリングはコレクション後に行われるため、テストファイルの実行をスキップすることはできません。また、各ファイルは独立して実行されるため、あるファイルの.onlyが他のファイルに影響を与えることはありません。」

**[例を表示]**

---

### スライド 22: テストライフサイクル - 実行マーカー
*17:30-17:45*

「では、実行に移りましょう。」

**[ライフサイクルの進行を示すシンプルなマーカースライド]**

---

## テストライフサイクル - 実行（4分）- 17:45-21:45

### スライド 23: テストの実行
*17:45-19:15*

「最後に各テスト関数を実行し、結果を記録します。」

**[実行を示すmagic-moveアニメーションをクリックしていく]**

「最初のテスト関数を実行し、結果を'passed'として記録します。次に2番目のテストで、エラーとdiffで失敗します。期間に'tests 3ms'と表示されています。シンプルなテストの場合、実行はコレクションよりもはるかに高速です。」

---

### スライド 24: テストAPI
*19:15-20:15*

「@vitest/runnerは、テスト実行を制御するための包括的なAPIを提供します：beforeAll/afterEachフック、並列実行のためのdescribe.concurrent、リトライとタイムアウトオプション、そしてパラメータ化されたテストのためのtest.forです。」

**[コードとタスクツリー表現の両方を表示]**

「これらすべてが、フック配列と設定を持つタスクツリー構造にキャプチャされます。」

---

### スライド 25: expect API
*20:15-21:15*

「expect APIは、@vitest/expectにChaiプラグインシステムとして実装されており、toEqualのようなJest互換マッチャーとChaiのAPIを提供します。スタンドアロンライブラリとして使用可能です。」

**[エラーフォーマットの例を表示]**

「エラーフォーマットは、テストランナー側での後処理によって行われます。生のアサーションエラーが@vitest/pretty-formatを使用して素敵なdiffに変換されます。」

---

### スライド 26: テストランナー認識アサーション
*21:15-21:45*

「一部のAPIはVitestのテストランナーと結合されています。例えば、expect.softは最初の失敗で停止する代わりに、複数のアサーションエラーを蓄積します。両方のエラーがテストの最後に表面化します。」

---

### スライド 27: テストライフサイクル - レポーティングマーカー
*21:45-22:00*

「最後に、レポーティングを見てみましょう。」

**[ライフサイクルの進行を示すシンプルなマーカースライド]**

---

## テストライフサイクル - レポーティング（3分）- 22:00-25:00

### スライド 28: レポーティングアーキテクチャ
*22:00-23:00*

「では、レポーティングです。メインプロセスは、テストランナーで何が起こっているかをどのように知るのでしょうか？イベントを通じてです：onCollectedはタスクツリーを送信し、onTaskUpdateはテスト結果をバッチで段階的に送信し、onConsoleLogはキャプチャされたコンソール出力を送信します。」

**[図を指す]**

---

### スライド 29: ランタイム通信
*23:00-23:45*

「この通信はbirpcを使用します。プロトコルに依存しない型付き双方向RPCライブラリです。子プロセスの場合はprocess.sendを使用し、ワーカースレッドの場合はparentPort.postMessageを使用し、ブラウザモードの場合はWebSocketを使用します。この双方向通信により、メインからテストランナーへのイベント送信も可能になり、Control+Cで正常に中断できます。」

---

### スライド 30-32: レポーターAPIと例
*23:45-25:00*

**[スライド 30 - API]**

「Vitestは、生のタスクツリーの代わりに正規化されたTestModule構造を持つReporter APIを提供します。BaseReporterを拡張して、結果の表示方法をカスタマイズできます。」

**[スライド 31 - デフォルトレポーター]**

「こちらが、私たちがずっと見てきたデフォルトレポーターの出力です。」

**[スライド 32 - GitHub Actionsレポーター]**

「そして、こちらがCIアノテーションと統合されたGitHub Actionsレポーターです。」

---

## Vite統合（8分）- 25:00-33:00

### スライド 33: Viteはどこに？
*25:00-25:30*

「テストライフサイクル全体をたどってきましたが、Viteはどこに登場するのでしょうか？」

**[クリックして表示]**

「期間の内訳を見てください。'transform 33ms'です。それがViteです。」

---

### スライド 34: テストランナーとVite Environment API
*25:30-26:15*

「こちらがクライアント-サーバーアーキテクチャです。NodeテストはVite SSRアプリケーションのように動作します。テストランナーはVite devサーバーにモジュール変換をリクエストするクライアントです。ブラウザモードは、ブラウザをクライアントとするViteクライアントアプリケーションのように動作します。」

---

### スライド 35: SSR / クライアント環境の例
*26:15-27:00*

「具体的な例：Vue SFC変換です。同じVueコンポーネントが異なる変換を受けます。クライアント環境はブラウザ用のレンダー関数を生成し、SSR環境はサーバーサイドレンダー関数を生成します。Viteは環境APIを通じてこれを処理します。」

---

### スライド 36: vite-node → Vite Environment API
*27:00-27:30*

「歴史的には、これはvite-nodeを使用していました。テストランナー側のViteNodeRunnerと、メインプロセスのViteNodeServerです。Vitest 4は、Viteの公式環境APIに移行しました。これはチーム間の素晴らしいコラボレーションです。」

---

### スライド 37: テストランナーインターフェース
*27:30-28:00*

「@vitest/runnerは、importFileとライフサイクルコールバックを持つVitestRunnerインターフェースを定義します。ViteモジュールランナーがModuleRunnerを使用してNode用にこれを実装します。ブラウザモードは、ネイティブブラウザのimportでこれを実装します。」

---

### スライド 38: Vite Module Runner
*28:00-28:45*

「モジュールランナーは、import/exportをランタイム関数に変換します。__vite_ssr_import__、__vite_ssr_exportName__などです。VITE_NODE_DEBUG_DUMP=true vitestまたはVitest 4のVITEST_DEBUG_DUMPを実行することで、これを自分で確認できます。」

**[変換例を表示]**

---

### スライド 39-40: モジュールモッキング
*28:45-29:30*

**[スライド 39 - 基本]**

「@vitest/mockerのモジュールモッキング：vi.mock('./add.js')を使用した自動モッキングは、エクスポートをスパイで深く置き換えます。ファクトリー関数を使用した手動モッキングは、カスタム実装を提供します。」

**[スライド 40 - 実装]**

「Vitestは、vi.mock呼び出しをインポートの前の最上部に変換するため、モッキング状態が最初に登録されます。その後、__vite_ssr_dynamic_import__がVitestによってインターセプトされ、モッキングが実装されます。」

---

### スライド 41-44: カバレッジ
*29:30-32:00*

**[スライド 41 - 例]**

「Vite機能がVitestをどのように強化しているかの別の例として、カバレッジを見てみましょう。こちらがシンプルなテストと、それが生成するカバレッジレポートです。」

**[テストとカバレッジ画像を表示]**

**[スライド 42 - 概要]**

「Vitestは2つの公式カバレッジプロバイダーを提供します：V8エンジンの組み込み追跡を使用するv8と、カバレッジカウンターを注入するカスタム変換を使用するistanbulです。どちらもIstanbulエコシステムツールを集約とレポーティングに使用します。カバレッジの始め方については、Ari PerkkiöのViteConfトークをご覧ください。」

**[設定例を表示]**

**[スライド 43 - Istanbul実装]**

「Istanbulは、カバレッジカウンターを注入するようにコードを変換することで動作します。すべての関数呼び出しと分岐が追跡されます。利点：どのJavaScriptランタイムでも動作します。欠点：変換のオーバーヘッドがテスト実行速度に影響します。」

**[変換を示すハイライトをクリックしていく]**

**[スライド 44 - V8実装]**

「V8プロバイダーは、カスタム変換を必要としないランタイムネイティブのカバレッジデータを使用します。ただし、後処理にはVite変換パイプライン全体を通じた正確なソースマップが必要です。V8インスペクターAPIが生のカバレッジデータを提供し、それがレポーティングのためにIstanbul形式に変換されます。」

---

## まとめ（1分）- 32:00-33:00

### スライド 45: 重要ポイント
*32:00-33:00*

「主要なアーキテクチャの洞察をまとめましょう：」

「1つ目：テストライフサイクルがアーキテクチャを駆動します。オーケストレーション、コレクション、実行、レポーティングを理解することが、テストフレームワーク設計の基本です。」

「2つ目：クライアント-サーバーアーキテクチャは、テストランナーがメインプロセスと通信することで、Node.js、ブラウザ、その他の環境にわたるランタイム非依存の実行を可能にします。」

「3つ目：基盤としてのVite。テストランタイムは、ViteのクライアントおよびSSRアプリケーションと同じ変換パイプラインとモジュールランナーを活用します。」

**[間を置く]**

「ご清聴ありがとうございました！質問をお受けします。」

---

## スピーカーノート

### 練習のヒント

**トーク前に、タイミングを確認しながら練習する：**

1. **各セクションを個別にタイミングを計る** - タイムマーカーを使用して、どのセクションが長い/短いかを特定：
   - イントロダクション（0:00-4:00）- 4分
   - 概要（4:00-7:00）- 3分
   - オーケストレーション（7:00-13:15）- 6分
   - コレクション（13:30-17:30）- 4分
   - 実行（17:45-21:45）- 4分
   - レポーティング（22:00-25:00）- 3分
   - Vite統合（25:00-33:00）- 8分

2. **自然な圧縮ポイントに注意：**
   - コード例 - すべてのコードを読み上げる必要はないかもしれません
   - 図 - 「見せて伝える」ことで時間を節約できます（特にプールアーキテクチャスライド12-15）
   - 繰り返しの概念 - 聴衆が理解したら、より速く進む
   - スライド間の移行 - これらはすぐに積み重なります

3. **実際には短くなりがちな共通領域：**
   - プールアーキテクチャスライド（12-15）- 図は自己説明的
   - レポーター例（30-32）- 素早いビジュアル例
   - モジュールランナー変換（38）- 見せることは説明するよりも速い
   - カバレッジ詳細（43-44）- 必要に応じて圧縮可能

4. **練習中のチェックポイントを使用：**
   - 10分時点：スライド14-15（分離）付近にいるべき
   - 20分時点：スライド24-25（テストAPI / expect）付近にいるべき
   - 25分時点：スライド33-34（Where is Vite / Environment API）付近にいるべき
   - 30分時点：スライド44（カバレッジV8または重要ポイント）以降にいるべき

5. **時間が長引いた場合の調整戦略：**
   - カバレッジセクション全体をスキップ（スライド41-44）- 2.5分節約
   - 分離例を圧縮（スライド17）- 30秒節約
   - レポーター例を素早く通過（スライド30-32）- 30秒節約
   - プールアーキテクチャ説明を高速化（スライド12-15）- 1分節約

6. **時間が短い場合の調整戦略：**
   - IstanbulとV8の詳細でカバレッジを拡張
   - コレクション中のタスクツリー構造により深く掘り下げる
   - birpcと通信パターンについて詳しく説明
   - モジュールモッキング実装により多くのコンテキストを追加

### ペースガイドライン
- **合計：33分** 最後にQ&A
- 明確で慎重に、速すぎないように話す
- アニメーションが完了してから続ける
- 聴衆のエンゲージメントを見る - 必要に応じて深さを調整
- イントロダクションを簡潔に保つ（4分）
- コアコンテンツはオーケストレーションからレポーティング（合計21分）
  - オーケストレーション（6分）
  - コレクション（4分）
  - 実行（4分）
  - レポーティング（3分）
  - 4つのマーカースライドを含む（各15秒）
- Vite統合（カバレッジ含む8分）
- まとめ（1分）
- 残りの時間はQ&A

### タイムマーカー（チェックポイント）
- 4分：概要を終えているべき
- 7分：テストオーケストレーション概要（スライド11）にいるべき
- 13分：分離についてのスライド（スライド16-17）付近にいるべき
- 17:30分：タスクのフィルタリングまたは実行マーカー（スライド21-22）にいるべき
- 22分：レポーティングを開始（スライド28）にいるべき
- 25分：「Viteはどこに？」（スライド33）にいるべき
- 29:30分：カバレッジを開始（スライド41）にいるべき
- 32分：重要ポイント（スライド45）にいるべき
- 33分：質問受付開始

### 柔軟性
- **時間が短い場合**: カバレッジ例を拡張、タスクツリー構造により深く掘り下げる、birpcをより詳細に説明、モジュールモッキングの詳細を詳しく説明
- **時間が長引いた場合**: 分離例を圧縮、レポーター例を素早く進む、カバレッジセクションを圧縮（概要を表示するがIstanbul/V8の詳細をスキップ）
- **技術的な問題**: 静的スライドを用意、アニメーションをスキップ、用意された例を使用
- **カバレッジセクションは柔軟**: 時間に応じて拡張（2.5分）または圧縮（1分）可能

### エンゲージメント
- 聴衆とアイコンタクトを取る
- 手のジェスチャーを使用してアーキテクチャの概念を強調（クライアント-サーバー、ライフサイクルフロー）
- Vite/VitestのコラボレーションとVitest 4リリースへの熱意を示す
- 技術的深さとアクセシビリティのバランスを取る
- 図やコードの特定の部分を指す

### 技術レベル
- 基本的なテスト知識を前提とする（describe、test、expect）
- 深いVite知識を前提としない - 進みながら概念を説明
- 他のフレームワークに適用可能なアーキテクチャパターンに焦点を当てる
- 実際のVitestコードベースからの具体例を使用
- 最初に言及するときに略語（RPC、SSRなど）を説明

### 重点ポイント
- アーキテクチャを理解するための組織原理としてのテストライフサイクル
- ランタイムの柔軟性の鍵としてのクライアント-サーバーアーキテクチャ
- 関心の分離：どの部分がフレームワークに依存しないか、Vite固有か
- このアーキテクチャを理解することが、より良いテストを書き、問題をデバッグするのに役立つ方法
- ViteとVitestチーム間のコラボレーション（vite-node → 環境API）

### 想定される質問への準備
- Vitestはパフォーマンス面でJestと比較してどうですか？
- ViteなしでVitestを使用できますか？
- ウォッチモードはどのように機能しますか？
- カバレッジ実装の詳細は？
- 失敗したテストをどのようにデバッグしますか？
- 大規模なテストスイートのベストプラクティスは？
